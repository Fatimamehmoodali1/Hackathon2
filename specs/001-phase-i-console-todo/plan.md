# Implementation Plan: Phase I Console Todo Application

**Branch**: `001-phase-i-console-todo` | **Date**: 2025-12-28 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/001-phase-i-console-todo/spec.md`

**Note**: This plan describes HOW the approved Phase I requirements will be implemented.

## Summary

Phase I delivers an in-memory Python console application for single-user todo task management. The application provides a menu-based CLI interface supporting five core operations: Add Task, View Tasks, Update Task, Delete Task, and Mark Task Complete/Incomplete. All data resides in memory during runtime with no persistence. The implementation follows Clean Architecture principles with clear separation between domain logic, application use cases, and CLI presentation.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: None (standard library only)
**Storage**: In-memory data structures (no persistence)
**Testing**: pytest with coverage plugin
**Target Platform**: Cross-platform console (Windows/macOS/Linux)
**Project Type**: Single console application
**Performance Goals**: Operations complete within 1 second for up to 100 tasks
**Constraints**: No external dependencies, no persistence, no network, single-threaded
**Scale/Scope**: Support up to 1000 tasks in memory, 5 core operations, menu-based navigation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Spec-Driven Development Mandate
- ✅ **PASS**: Plan derived strictly from approved spec.md
- ✅ **PASS**: No new features introduced beyond specification
- ✅ **PASS**: All design decisions traceable to functional requirements

### II. Agent Behavior Rules
- ✅ **PASS**: No features invented beyond approved specification
- ✅ **PASS**: Architecture stays within Phase I boundaries
- ✅ **PASS**: Implementation approach documented for approval

### III. Phase Governance
- ✅ **PASS**: Phase I scope strictly maintained (no persistence, no multi-user, no web)
- ✅ **PASS**: Out-of-scope features explicitly excluded (17 items documented)
- ✅ **PASS**: Phase isolation maintained (no leakage from future phases)

### IV. Technology Stack Constraints
- ✅ **PASS**: Python 3.11+ as mandated by constitution
- ✅ **PASS**: No unauthorized frameworks or libraries
- ⚠️ **DEVIATION**: FastAPI/SQLModel not used (Phase I is console-only, no web/database)
  - **Justification**: Phase I specification explicitly excludes web/API interfaces and databases
  - **Simpler Alternative**: Standard library only, as required by Phase I scope
  - **Constitutional Compliance**: Deviation is specification-driven, not arbitrary

### V. Clean Architecture Principles
- ✅ **PASS**: Domain layer (Task entity) separated from infrastructure
- ✅ **PASS**: Application layer (use cases) isolated from CLI
- ✅ **PASS**: Dependency inversion applied (CLI depends on domain, not vice versa)
- ✅ **PASS**: Business logic framework-agnostic

### VI. Testing and Quality Standards
- ✅ **PASS**: TDD approach planned (tests written before implementation)
- ✅ **PASS**: Unit tests for domain models and use cases
- ✅ **PASS**: Integration tests for CLI workflows
- ✅ **PASS**: All acceptance scenarios from spec converted to tests

### VII. Stateless Design Principles
- ✅ **PASS**: Application is stateless (state exists only in memory during runtime)
- ✅ **PASS**: No session management needed (single-user console app)
- ✅ **N/A**: Horizontal scaling not applicable to Phase I console application

### VIII. Cloud-Native Readiness
- ✅ **N/A**: Phase I is console-only, cloud-native principles apply from Phase III+
- ✅ **PASS**: Architecture designed to allow cloud evolution in future phases

**GATE STATUS: PASS** ✅ (1 justified deviation, all principles satisfied)

## Project Structure

### Documentation (this feature)

```text
specs/001-phase-i-console-todo/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0: Technology decisions and patterns
├── data-model.md        # Phase 1: Domain model and state management
├── quickstart.md        # Phase 1: Development setup and usage guide
├── contracts/           # Phase 1: Internal API contracts (Python interfaces)
└── tasks.md             # Phase 2: Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
src/
├── domain/
│   ├── __init__.py
│   ├── task.py          # Task entity with ID, description, status
│   └── task_repository.py  # Abstract interface for task storage
├── application/
│   ├── __init__.py
│   ├── task_service.py  # Business logic: add, update, delete, toggle status
│   └── errors.py        # Domain exceptions (TaskNotFound, InvalidInput)
├── infrastructure/
│   ├── __init__.py
│   └── in_memory_repository.py  # In-memory implementation of task_repository
├── cli/
│   ├── __init__.py
│   ├── menu.py          # Main menu loop and user input handling
│   ├── commands.py      # Command handlers for each menu option
│   └── display.py       # Output formatting and messages
└── main.py              # Application entry point

tests/
├── unit/
│   ├── test_task.py               # Task entity tests
│   ├── test_task_service.py       # Business logic tests
│   └── test_in_memory_repository.py  # Repository implementation tests
├── integration/
│   ├── test_cli_workflows.py      # End-to-end CLI scenarios
│   └── test_acceptance_scenarios.py  # Spec acceptance criteria as tests
└── conftest.py          # Shared pytest fixtures
```

**Structure Decision**: Single project structure chosen (Option 1) because Phase I is a standalone console application with no web frontend/backend split. The structure follows Clean Architecture with four distinct layers: domain (entities), application (use cases), infrastructure (implementations), and cli (presentation). This design allows future phases to reuse domain and application layers while replacing infrastructure and presentation layers (e.g., CLI → Web API → Microservices).

## Complexity Tracking

No constitutional violations requiring justification. The single deviation (no FastAPI/SQLModel) is specification-driven and uses a simpler alternative (standard library only) as required by Phase I scope.

## Phase 0: Research & Technology Decisions

### Research Areas

1. **ID Generation Strategy**: Determine best approach for sequential ID generation
   - Decision needed: Simple counter vs UUID vs other
   - Requirements: Sequential, never reused, starts at 1

2. **In-Memory Storage Pattern**: Select appropriate data structure for task storage
   - Decision needed: List vs Dict vs custom structure
   - Requirements: Fast lookup by ID, preserve insertion order, support deletion

3. **CLI Input Validation**: Establish patterns for validating user input
   - Decision needed: Validation approach (inline, decorator, separate validator)
   - Requirements: Validate ID format (numeric), non-empty descriptions

4. **Error Handling Strategy**: Define how errors propagate through layers
   - Decision needed: Exception types, error messages, recovery patterns
   - Requirements: Clear messages, no crashes, graceful degradation

5. **Testing Approach**: Determine test organization and fixture strategy
   - Decision needed: Test structure, mocking approach, fixture patterns
   - Requirements: TDD-compatible, isolated tests, acceptance scenario coverage

### Research Output

**File**: `specs/001-phase-i-console-todo/research.md`

**Format**:
```markdown
# Research Findings: Phase I Console Todo

## 1. ID Generation Strategy

**Decision**: Simple counter with monotonically increasing integers

**Rationale**:
- Meets all requirements (sequential, never reused, starts at 1)
- Simplest possible implementation (single integer variable)
- No external dependencies needed
- Performance: O(1) for ID generation

**Alternatives Considered**:
- UUID: Rejected (overkill for single-user app, not sequential)
- Timestamp-based: Rejected (not guaranteed sequential, potential collisions)

## 2. In-Memory Storage Pattern

**Decision**: Dictionary with integer keys (task ID → Task object)

**Rationale**:
- O(1) lookup by ID for all operations
- Preserves insertion order (Python 3.7+ dict guarantee)
- Supports efficient deletion without shifting IDs
- Simple iteration for "View All" operation

**Alternatives Considered**:
- List: Rejected (O(n) lookup, ID gaps after deletion complicate indexing)
- Custom linked structure: Rejected (unnecessary complexity)

## 3. CLI Input Validation

**Decision**: Separate validation functions with early returns

**Rationale**:
- Clear separation of concerns (validation vs business logic)
- Reusable validation functions
- Easy to test in isolation
- Explicit error messages for each validation rule

**Alternatives Considered**:
- Inline validation: Rejected (clutters business logic)
- Decorator-based: Rejected (over-engineered for Phase I scope)

## 4. Error Handling Strategy

**Decision**: Custom domain exceptions with message templates

**Rationale**:
- Type-safe error handling (catch specific exceptions)
- Consistent error messages (templates in one place)
- Clean separation (domain exceptions vs infrastructure errors)
- Easy to extend for future phases

**Exception Hierarchy**:
- `TodoError` (base exception)
  - `TaskNotFoundError(task_id)`
  - `InvalidTaskIdError(input_value)`
  - `EmptyDescriptionError()`

**Alternatives Considered**:
- Generic exceptions: Rejected (loses type information)
- Error codes: Rejected (less Pythonic, harder to handle)

## 5. Testing Approach

**Decision**: pytest with fixture-based setup, AAA pattern

**Rationale**:
- Industry standard for Python testing
- Excellent fixture support for test isolation
- Clear test structure (Arrange-Act-Assert)
- Coverage plugin available

**Test Organization**:
- Unit tests: One test file per source module
- Integration tests: One test file per user story
- Fixtures: Shared in conftest.py (fresh repository, sample tasks)

**Alternatives Considered**:
- unittest: Rejected (more verbose, class-based)
- doctest: Rejected (insufficient for acceptance scenarios)
```

## Phase 1: Design & Contracts

### 1. Data Model

**File**: `specs/001-phase-i-console-todo/data-model.md`

**Content**:
```markdown
# Data Model: Phase I Console Todo

## Domain Entities

### Task

**Purpose**: Represents a single todo item with unique identifier, description, and completion status.

**Attributes**:

| Attribute | Type | Constraints | Default | Description |
|-----------|------|-------------|---------|-------------|
| id | int | Positive integer, unique, never reused | Auto-generated | Unique identifier for the task |
| description | str | Non-empty, supports Unicode | Required | Text describing what needs to be done |
| is_complete | bool | True or False | False | Indicates whether the task is finished |

**Invariants**:
- ID is assigned at creation and never changes
- ID sequence is monotonically increasing (1, 2, 3, ...)
- Description cannot be empty string or whitespace-only
- is_complete can be toggled between True and False

**State Transitions**:
```
[Created] → is_complete = False (default)
          ↓
[Active]  ← → [Complete]
          ↑
  (toggle status)
          ↓
[Deleted] (removed from storage)
```

**Validation Rules**:
- Description: `len(description.strip()) > 0`
- ID: Positive integer, assigned by system (user cannot set)

## State Management

**Storage Abstraction**: `TaskRepository` (abstract interface)

**Operations**:
- `add(task: Task) -> None`: Store a new task
- `get(task_id: int) -> Optional[Task]`: Retrieve task by ID
- `get_all() -> List[Task]`: Retrieve all tasks
- `update(task: Task) -> None`: Update existing task
- `delete(task_id: int) -> None`: Remove task from storage
- `exists(task_id: int) -> bool`: Check if task exists

**Implementation**: `InMemoryTaskRepository`

**Data Structure**: `dict[int, Task]`
- Key: Task ID (int)
- Value: Task object
- Guarantees: O(1) lookup, insertion order preserved (Python 3.7+)

**ID Generation**:
- Counter: `_next_id` (starts at 1)
- Increment: `_next_id += 1` after each task creation
- Thread-safety: Not required (single-threaded application)

## Business Logic Layer

**Service**: `TaskService`

**Responsibilities**:
- Orchestrate task operations (CRUD + toggle status)
- Validate inputs before repository operations
- Translate repository results to domain exceptions
- Generate IDs for new tasks

**Dependencies**:
- `TaskRepository` (injected via constructor)

**Methods**:

| Method | Input | Output | Exceptions |
|--------|-------|--------|------------|
| add_task(description: str) | description | Task | EmptyDescriptionError |
| get_task(task_id: int) | task_id | Task | TaskNotFoundError, InvalidTaskIdError |
| get_all_tasks() | None | List[Task] | None |
| update_task(task_id: int, description: str) | task_id, description | Task | TaskNotFoundError, InvalidTaskIdError, EmptyDescriptionError |
| delete_task(task_id: int) | task_id | None | TaskNotFoundError, InvalidTaskIdError |
| mark_complete(task_id: int) | task_id | Task | TaskNotFoundError, InvalidTaskIdError |
| mark_incomplete(task_id: int) | task_id | Task | TaskNotFoundError, InvalidTaskIdError |

**Validation Logic**:
- Description: Strip whitespace, check non-empty
- Task ID: Check numeric (handled by CLI), verify exists in repository

## CLI Presentation Layer

**Components**:

1. **Menu** (`cli/menu.py`):
   - Display main menu with 7 options
   - Capture user choice (1-7)
   - Route to appropriate command handler
   - Loop until user selects Exit

2. **Commands** (`cli/commands.py`):
   - One handler function per menu option
   - Call TaskService methods
   - Handle exceptions and display errors
   - Display success confirmations

3. **Display** (`cli/display.py`):
   - Format task output (ID, description, status)
   - Format messages (error, success, info)
   - Clear screen (optional, for better UX)

**Menu Options**:
```
1. Add Task
2. View Tasks
3. Update Task
4. Delete Task
5. Mark Complete
6. Mark Incomplete
7. Exit
```

**User Flow**:
```
Start → Display Menu → Get User Choice → Execute Command → Display Result → Return to Menu
                                         ↓
                                    (Choice 7: Exit)
                                         ↓
                                    End Program
```
```

### 2. API Contracts

**Directory**: `specs/001-phase-i-console-todo/contracts/`

**File**: `task_repository_interface.py`

```python
"""
Task Repository Interface Contract

This defines the abstract interface that all task storage implementations must follow.
Phase I uses InMemoryTaskRepository; future phases may add DatabaseTaskRepository.
"""

from abc import ABC, abstractmethod
from typing import List, Optional
from ..domain.task import Task


class TaskRepository(ABC):
    """Abstract repository for task storage and retrieval."""

    @abstractmethod
    def add(self, task: Task) -> None:
        """
        Store a new task.

        Args:
            task: Task object to store

        Raises:
            None (implementation-specific errors may be raised)
        """
        pass

    @abstractmethod
    def get(self, task_id: int) -> Optional[Task]:
        """
        Retrieve a task by its ID.

        Args:
            task_id: Unique identifier of the task

        Returns:
            Task object if found, None otherwise
        """
        pass

    @abstractmethod
    def get_all(self) -> List[Task]:
        """
        Retrieve all tasks.

        Returns:
            List of all Task objects (may be empty)
        """
        pass

    @abstractmethod
    def update(self, task: Task) -> None:
        """
        Update an existing task.

        Args:
            task: Task object with updated values

        Raises:
            None (caller should verify task exists before calling)
        """
        pass

    @abstractmethod
    def delete(self, task_id: int) -> None:
        """
        Remove a task from storage.

        Args:
            task_id: Unique identifier of the task to delete

        Raises:
            None (implementation may raise if task not found)
        """
        pass

    @abstractmethod
    def exists(self, task_id: int) -> bool:
        """
        Check if a task exists.

        Args:
            task_id: Unique identifier of the task

        Returns:
            True if task exists, False otherwise
        """
        pass

    @abstractmethod
    def get_next_id(self) -> int:
        """
        Get the next available task ID.

        Returns:
            Next sequential ID for a new task
        """
        pass
```

**File**: `task_service_interface.py`

```python
"""
Task Service Interface Contract

This defines the public API for task management business logic.
All CLI commands interact with tasks through this service interface.
"""

from abc import ABC, abstractmethod
from typing import List
from ..domain.task import Task


class TaskService(ABC):
    """Abstract service for task management operations."""

    @abstractmethod
    def add_task(self, description: str) -> Task:
        """
        Create and store a new task.

        Args:
            description: Task description text

        Returns:
            Created Task object with assigned ID

        Raises:
            EmptyDescriptionError: If description is empty or whitespace-only
        """
        pass

    @abstractmethod
    def get_task(self, task_id: int) -> Task:
        """
        Retrieve a task by ID.

        Args:
            task_id: Unique identifier of the task

        Returns:
            Task object

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            InvalidTaskIdError: If task_id is not a valid integer
        """
        pass

    @abstractmethod
    def get_all_tasks(self) -> List[Task]:
        """
        Retrieve all tasks.

        Returns:
            List of all Task objects (may be empty)
        """
        pass

    @abstractmethod
    def update_task(self, task_id: int, description: str) -> Task:
        """
        Update a task's description.

        Args:
            task_id: Unique identifier of the task
            description: New description text

        Returns:
            Updated Task object

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            InvalidTaskIdError: If task_id is not a valid integer
            EmptyDescriptionError: If description is empty or whitespace-only
        """
        pass

    @abstractmethod
    def delete_task(self, task_id: int) -> None:
        """
        Delete a task.

        Args:
            task_id: Unique identifier of the task

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            InvalidTaskIdError: If task_id is not a valid integer
        """
        pass

    @abstractmethod
    def mark_complete(self, task_id: int) -> Task:
        """
        Mark a task as complete.

        Args:
            task_id: Unique identifier of the task

        Returns:
            Updated Task object with is_complete=True

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            InvalidTaskIdError: If task_id is not a valid integer
        """
        pass

    @abstractmethod
    def mark_incomplete(self, task_id: int) -> Task:
        """
        Mark a task as incomplete.

        Args:
            task_id: Unique identifier of the task

        Returns:
            Updated Task object with is_complete=False

        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
            InvalidTaskIdError: If task_id is not a valid integer
        """
        pass
```

### 3. Quickstart Guide

**File**: `specs/001-phase-i-console-todo/quickstart.md`

```markdown
# Quickstart Guide: Phase I Console Todo

## Prerequisites

- Python 3.11 or higher
- pip (Python package installer)
- Git (for cloning repository)

## Installation

1. Clone the repository:
   ```bash
   git clone <repository-url>
   cd phase1
   ```

2. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install development dependencies:
   ```bash
   pip install -r requirements-dev.txt
   ```

## Running the Application

From the repository root:

```bash
python -m src.main
```

You should see the main menu:

```
=== Todo Application ===
1. Add Task
2. View Tasks
3. Update Task
4. Delete Task
5. Mark Complete
6. Mark Incomplete
7. Exit

Enter your choice (1-7):
```

## Running Tests

Run all tests:
```bash
pytest
```

Run with coverage:
```bash
pytest --cov=src --cov-report=term-missing
```

Run specific test file:
```bash
pytest tests/unit/test_task.py
```

## Development Workflow

1. **Write Tests First** (TDD Red-Green-Refactor):
   ```bash
   # 1. Write failing test
   pytest tests/unit/test_task.py::test_new_feature  # RED (fails)

   # 2. Implement minimum code to pass
   # Edit src/domain/task.py
   pytest tests/unit/test_task.py::test_new_feature  # GREEN (passes)

   # 3. Refactor if needed
   pytest  # All tests still pass
   ```

2. **Check Code Quality**:
   ```bash
   # Run linter
   pylint src/

   # Run type checker
   mypy src/

   # Run formatter
   black src/ tests/
   ```

3. **Verify Acceptance Scenarios**:
   ```bash
   pytest tests/integration/test_acceptance_scenarios.py -v
   ```

## Project Structure

```
src/
├── domain/          # Business entities (Task)
├── application/     # Business logic (TaskService)
├── infrastructure/  # Storage implementation (InMemoryRepository)
├── cli/             # User interface (Menu, Commands, Display)
└── main.py          # Application entry point

tests/
├── unit/            # Unit tests for each module
├── integration/     # End-to-end workflow tests
└── conftest.py      # Shared test fixtures
```

## Example Usage Session

```
=== Todo Application ===
1. Add Task
2. View Tasks
...
Enter your choice (1-7): 1

Enter task description: Buy groceries
✓ Task added successfully (ID: 1)

Enter your choice (1-7): 1

Enter task description: Call dentist
✓ Task added successfully (ID: 2)

Enter your choice (1-7): 2

=== All Tasks ===
ID: 1 | Buy groceries | Status: Incomplete
ID: 2 | Call dentist | Status: Incomplete

Enter your choice (1-7): 5

Enter task ID to mark complete: 1
✓ Task marked complete (ID: 1)

Enter your choice (1-7): 2

=== All Tasks ===
ID: 1 | Buy groceries | Status: Complete
ID: 2 | Call dentist | Status: Incomplete

Enter your choice (1-7): 7

Goodbye!
```

## Troubleshooting

**Issue**: `ModuleNotFoundError: No module named 'src'`
- **Solution**: Ensure you're running from the repository root, not inside `src/`

**Issue**: Tests fail with import errors
- **Solution**: Activate virtual environment and reinstall dependencies

**Issue**: Application doesn't exit
- **Solution**: Use menu option 7 or press Ctrl+C

## Next Steps

After Phase I is complete and tested:
- Phase II: Web interface with FastAPI backend
- Phase III: Database persistence with SQLModel + Neon DB
- Phase IV: Multi-user support with authentication
- Phase V: Advanced features (priorities, due dates, categories)

For more details, see the [Implementation Plan](plan.md).
```

## Phase 2: Task Generation

**Note**: Phase 2 (task generation) is handled by the `/sp.tasks` command, which will:
1. Load this plan.md and spec.md
2. Generate detailed implementation tasks in `specs/001-phase-i-console-todo/tasks.md`
3. Organize tasks by priority and dependencies
4. Include TDD red-green-refactor cycles for each task

This plan provides the necessary foundation for task generation.

## Architecture Decisions

### 1. Clean Architecture Layers

**Decision**: Implement four distinct layers (domain, application, infrastructure, cli)

**Rationale**:
- Enables independent testing of business logic
- Allows future phases to replace CLI with web API
- Maintains dependency inversion (infrastructure depends on domain)
- Prevents framework coupling

**Trade-offs**:
- More files and abstractions than a simple script
- Overhead for small application
- **Justified by**: Constitutional requirement (Section V) and Phase evolution needs

### 2. Repository Pattern

**Decision**: Abstract storage behind TaskRepository interface

**Rationale**:
- Phase I uses in-memory; future phases need database
- Testability (mock repository in unit tests)
- Single Responsibility Principle (storage separate from business logic)

**Trade-offs**:
- Additional abstraction layer
- More complex than direct dictionary access
- **Justified by**: Multi-phase evolution and constitutional clean architecture requirement

### 3. No External Dependencies

**Decision**: Standard library only (except pytest for testing)

**Rationale**:
- Phase I specification explicitly excludes databases, web frameworks
- Simplifies deployment and setup
- Reduces attack surface
- Aligns with educational nature of Phase I

**Trade-offs**:
- Manual CLI input handling (no Click/Typer)
- No fancy output formatting (no Rich/Colorama)
- **Justified by**: Specification constraint and simplicity principle

### 4. Exception-Based Error Handling

**Decision**: Domain exceptions for business rule violations

**Rationale**:
- Type-safe error handling
- Clear separation between business errors and system errors
- Pythonic approach
- Easy to extend with additional error types

**Trade-offs**:
- More exception classes to maintain
- Potential performance overhead (negligible for this use case)
- **Justified by**: Constitutional testing requirements and code quality standards

## Implementation Sequence

The `/sp.tasks` command will generate detailed tasks, but the high-level sequence is:

1. **Domain Layer** (TDD):
   - Task entity with validation
   - Custom exceptions
   - Unit tests for task creation, validation, state transitions

2. **Infrastructure Layer** (TDD):
   - TaskRepository interface
   - InMemoryTaskRepository implementation
   - Unit tests for repository operations

3. **Application Layer** (TDD):
   - TaskService with all CRUD operations
   - Business logic validation
   - Unit tests for each service method

4. **CLI Layer** (Integration Tests):
   - Menu display and input capture
   - Command handlers
   - Display formatting
   - Integration tests for user workflows

5. **Acceptance Testing**:
   - Implement all 13 acceptance scenarios from spec
   - Verify 6 edge cases
   - Confirm all 7 success criteria

6. **Documentation**:
   - README with setup instructions
   - Code comments for public interfaces
   - Type hints for all functions

## Success Validation

Before considering Phase I complete, verify:

- ✅ All 12 functional requirements (FR-001 through FR-012) implemented
- ✅ All 13 acceptance scenarios pass as automated tests
- ✅ All 6 edge cases handled gracefully
- ✅ All 7 success criteria measurably satisfied
- ✅ Test coverage >90% for domain and application layers
- ✅ All constitutional principles satisfied
- ✅ No scope creep (no features beyond specification)
- ✅ Clean exit (no crashes, errors, or warnings)

## Notes

- This plan is approved alongside the specification; implementation via `/sp.tasks` may begin
- All architectural decisions are traceable to constitutional principles or specification requirements
- No ADRs needed at this stage (decisions are straightforward and specification-driven)
- Future phases will build on this architecture by replacing infrastructure and presentation layers
